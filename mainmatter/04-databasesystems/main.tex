\chapter{On The Design of a Database Management System}
\label{chapter:theory_databases}

\epiquote{Under third normal form, a non-key field must provide a fact about the key, use the whole key, and nothing but the key.}{William Kent}

\gls{dbms}{}, or simply ``databases'', power everything from small and simple websites to large data warehouses that serve millions of users in parallel. Database systems play a crucial role in banking, e-commerce, science, entertainment and practically every aspect of our socio-economic lives. The first commercial \gls{dbms} systems were introduced in the 1960s \cite{Garcia:2009Database} and they have evolved ever since to adapt to a wide range of requirements. Even though many different flavours of \gls{dbms} have emerged over the years, at their core, they still serve the same, fundamental purpose:

\begin{description}
    \item[Management \& Definition] \glsname{dbms} provide mechanisms to structure and organize data corpora that can range from a few megabytes to houndreds of terrabytes in size. For example, data can be structured into documents, relations or graph-like structures.
    \item[Manipulation] \glsname{dbms} provide users with the ability to modify the data using a \gls{dml}. Modifications may include adding, removing or changing existing entries.
    \item[Querying] \glsname{dbms} provide users with the ability to query the data using a \gls{dql}. Such queries can be used to answer specific ``questions'' about the data.
    \item[Guarantees] \glsname{dbms} usually provide guarantees for the execution of the aforementioned, such as assuring durability upon failure or providing access control for concurrent read and write operations. A famous set of guarantees is known by its acronym ACID -- which stands for \textbf{A}tomicity, \textbf{C}onsistency, \textbf{I}solation and \textbf{D}urability~\cite{Haerder:1983principles}.
\end{description}

Since the contributions of this Thesis rely on decades of database research, we use this chapter to provide a brief overview over the relevant fundamentals. Most of the basic aspects are inspired by \cite{Garcia:2009Database} and \cite{Petrov:2019Database}.


\section{The Relational Data Model}
\label{section:relational_data_model}

A data model is a formal framework that describes any type of data or information. It usually involves a formal description of the data's \emph{structure}, the \emph{operations} that can be performed and the \emph{constraints} that should be imposed on the data~\cite{Garcia:2009Database}. The purpose of any data model is to formalize how data governed by it can be accessed, modified and queried.

In the context of database systems, it has become common practice to make a clear distinction between the \emph{physical data model} and the a higher-level \emph{logical data model}. While the former captures low-level structure (representation in bits and bytes, data structures etc.) and operations (reads and writes), the latter describes higher-level semantics (attributes, relationships etc.). The argument for this separation is that ``users'' of any \gls{dbms} should not concern themselves with how exactly data is organized and accessed at the lowest level.

In June 1970, E. F. Codd published his pivotal research article \emph{Relational Model of Data for Large Shared Data Banks}~\cite{Codd:1970Relational} in which he describes such a logical data model for databases, which he himself refers to as ``relational''. This model has become the fundament on which many if not most of the modern database management systems have been built in the past decades. 

The relational model is structured around \emph{relations}, which are a mathematical construct but can be visualized as two-dimensional tables. Such a table consists of columns -- which are called \emph{attributes} -- and rows -- which are called \emph{tuples} and hold \emph{attribute values}. \cref{example:relational_table} features a relation \emph{paintings} and each entry in the table represents a painting and the related attribute values for attributes \emph{title}, \emph{artist} and \emph{painted}. Note, that we already use the mathematical notation introduced in \cref{defintion:relation}.

\begin{example}[label=example:relational_table]{Table Representation of a Relation $\symrel_{paintings}$}{}
    
    The following table lists the content of a ternary relation ($N = 3$) $\mathcal{R}_{paintings}$. The attributes $\symattr_{title}, \symattr_{artist}, \symattr_{id}$ correspond to the table's columns. The individual tuples $t_i$ are ``valid'' combinations of identifier, painting title and artist and constitute the rows.
        
    \begin{center}
        \begin{tabular}{ l || l | l | l |}
            $\mathcal{R}_{paintings}$ & $\symattrp_{title}$  & $\symattr_{artist}$  & $\symattr_{painted}$ \\ 
            \hline
            \hline
            $t_1$ & Mona Lisa &  Leonardo da Vinci & 1506 \\
            \hline
            $t_2$ & The Starry Night & Vincent van Gogh & 1889 \\
            \hline
            $t_3$ & Las Meninas & Diego VelÃ¡zquez & 1665 \\
            \hline
        \end{tabular}
    \end{center}
\end{example}

In order to formalize the structure of and the operations that can be executed on the data represented by a relation, one can use \cref{defintion:relation}. 

\begin{definition}[label=defintion:relation]{Relation according to \cite{Codd:1970Relational}}{}
    Given $i,j,N \in \symnatural_{> 0}$ and a collection of sets $\symdomain_1, \symdomain_2, ... \symdomain_N$, a \emph{relation} $\mathcal{R}$ on these sets is a set of \emph{tuples} $t_i = (a_{i,1}, a_{i,2} ... a_{i,n}) \in \mathcal{R}$ such that the attribute values $a_{i,1} \in \symdomain_1, a_{i,2} \in \symdomain_2 ... a_{i,N} \in \symdomain_N$. Ergo, $\mathcal{R}$ is a subset of the Cartesian product of the relation's \emph{data domains} $\symdomain_j$, that is, $\symdomain_1 \times \symdomain_2 ... \times \symdomain_N$. The number of data domains $N$ is referred to as the relation's \emph{degree} and we call a relation \emph{N-ary}, e.g., binary for $N=2$. 
\end{definition}


The relational model does not dictate what the data domains should be. However, in a relational database system, the data domains $\symdomain_1, \symdomain_2, ... \symdomain_N$ usually correspond to the data types supported by the database, for example, \lstinline{Int} for integer numbers, \lstinline{Float} for floating point numbers or \lstinline{Varchar} for text \footnote{Strictly speaking as per definition, the data domains of a given relation $\mathcal{R}$ are merely subsets of the sets that represent the respective data type which, in turn, are subsets of even more basic sets such as $\symnatural$ or $\symreal$ for \lstinline{Int} and \lstinline{Float} respectively. The relationship between types and data domains is subject of a more categorical approach to data models and nicely layed out in \cite{Spivak:2009Simplicial}}. To keep things simple, we will use \emph{data domain} synonymous for \emph{data type}. The combination of a data domain with a human readable label is called attribute and we will use subscripts to indicate an attribute's name or index, that is, $\symattr_{name} = (\symdomain, name)$. In its original form, the relational model assumes the following properties to be true for a relation $\mathcal{R}$ and its attributes~\cite{Codd:1970Relational}:

\begin{description}
    \item[Ordering of tuples] Tuples $t_i \in \mathcal{R}$ are inherently unordered and two relations are considered equal if they contain the same tuples, regardless of order.
    \item[Ordering of attributes] Attribute values $a_{i,j}$ always occur in the same order within the $t_i \in \mathcal{R}$, which corresponds to the order of the attributes $\symattr_j$. This order can evolve over time but remains constant in a momentary snapshot of $\mathcal{R}$.
    \item[Duplicates] Relations do not allow for duplicates, i.e., every tuple $t_i$ must be unique in terms of their attributes.
    \item[Atomicity] The attribute values in a tuple $t_i$ are considered to be atomic, i.e., it is not possible to further decompose them.
\end{description}

Given the notion and the properties of a relation $\mathcal{R}$, one can introduce the idea of a \emph{heading} or \emph{schema} $\mathtt{SCH}(\mathcal{R})$ and \emph{body} or \emph{extent} $\mathtt{EXT}(\mathcal{R})$ of a relation. Which are the set of attributes and tuples respectively that make up $\mathcal{R}$.

\begin{equation}
    \mathtt{SCH}(\mathcal{R}) = \lbrace \symattr_1, \symattr_2, ... \symattr_N \rbrace
\end{equation}

\begin{equation}
    \mathtt{EXT}(\mathcal{R}) = \lbrace (a_{1,1}, ..., a_{1,N}), ... (a_{M,1}, ..., a_{M,N})\rbrace, a_{i,j} \in \symdomain_j 
\end{equation}

The sum of all data contained in a database system can be regarded as a collection of different relations $\mathcal{R}_k, k \in \symnatural_{\geq 0}$ of assorted degrees $N_k$ and data domains $\symdomain_j \in \mathbb{D}$, with $\mathbb{D}$ being the set of all data domains supported by the system. The schema of a database can then be seen as the sum of all $\mathtt{SCH}(\mathcal{R}_k)$. As \cite{Codd:1970Relational} points out, relations are subject to change over time, which are changes to either $\mathtt{SCH}(\mathcal{R})$ or $\mathtt{EXT}(\mathcal{R})$, for example, by tuples being added to (insert) or removed from (delete) a relation, or by altering one or multiple attributes.


\subsection{Keys and Normal Forms}

The notion of a relation introduced in the previous section provides us with the basic tools for data modeling. \cite{Codd:1970Relational} proposed a wide range of additional constraints to guarantee proper data definition using the relational model and the following, additional definitions. 

\begin{description}
    \item[Primary key] A \emph{primary key} is a combination of attributes $P \subset \mathtt{SCH}(\mathcal{R})$ that uniquely identify a tuple $t_i \in \mathcal{R}$. That is, the attributes $\mathtt{SCH}(\mathcal{R}) \setminus P$ and their values are functionally determined by $P$.
    \item[Foreign key] Foreign keys are attributes $F \subset \mathtt{SCH}(\mathcal{R})$ that are not primary keys but reference the primary key of $R$ or some other relation $R_k$. Foreign keys can be used to model relationships between relations.
\end{description}

An example of relations with primary and foreign key attributes is given in \cref{example:relational_table_pkfk}. Primary keys are indicated with a * and foreign keys are underlined.

\begin{example}[label=example:relational_table_pkfk]{Relations with Primary and Foreign Keys}{}
    
    The following tables lists the heading and the body of relations $\mathcal{R}_{paintings}$ and $\mathcal{R}_{artists}$.  Note that $\mathcal{R}_{paintings}$ only contains attributes that are functionally dependend on the painting, identified by $\symattr_{title}$. Information about the artist, e.g. their date of birth, do not depend on the the title of the paining and thus belong to another relation.
        
    \begin{center}
        \begin{tabular}{ l || l | l | l |}
            $\mathcal{R}_{paintings}$ & $\symattrp_{title}$  & $\symattr_{artist}$  & $\symattr_{painted}$ \\ 
            \hline
            \hline
            $t_1$ & Mona Lisa &  1 & 1506 \\
            \hline
            $t_2$ & The Starry Night & 2 & 1889 \\
            \hline
            $t_3$ & Las Meninas & 3 & 1665 \\
            \hline
        \end{tabular}
    \end{center}

    \begin{center}
        \begin{tabular}{ l || l | l | l | l | l |}
            $\mathcal{R}_{artist}$ & $\symattrp_{id}$ & $\symattr_{fname}$ & $\symattr_{lname}$ & $\symattr_{birth}$ & $\symattr_{death}$\\ 
            \hline
            \hline
            $t_1$ & 1 & Leonardo & da Vinci & 1452 & 1519 \\
            \hline
            $t_2$ & 2 & Vincent & van Gogh & 1853 & 1890 \\
            \hline
            $t_3$ & 3 & Diego & VelÃ¡zquez & 1599 & 1660 \\
            \hline
        \end{tabular}
    \end{center}

    Note, that we used an artifical primary key for $\mathcal{R}_{artists}$, which is often done in practice.
\end{example}


\subsection{Relational Algebra}
\label{section:rel_algebra}

\subsection{Extensions}
\label{section:rel_extensions}


\subsubsection{Extended Projection}

\subsubsection{Ranked Relational Algebra}

\subsubsection{Similarity Search and the Relational Model}

Using the relationship between (diss-)similarity and distance, it has been shown by Giangreco et al., that for a database system to be able to support similarity search given the relational model for databases as described in \cref{section:relational_data_model}, one can extend the set system of allowed data domains $\mathbb{D}$ by $\symdomain \subset \symreal^{dim}, dim \in \symnatural_{>1}$ and postulate the existence of a relational similarity operator $\tau_{\delta(\cdot,\cdot),a,q}(R)$ that \emph{``performs a similarity query under a distance $\delta(\cdot,\cdot)$ applied on an attribute $a$ of relation $R$ and compared to a query vector $q$.''} (\cite{Giangreco:2018thesis}, p. 138). Such an operation introduces an implicit attribute in the underlying relation $\mathcal{R}$, which in turn induces an ascending ordering of the tuples. Using this operation, one can go on to define two concrete implementations, namely $\tau^{kNN}_{\delta(\cdot,\cdot),a,q}(\mathcal{R})$, and $\tau^{\epsilon NN}_{\delta(\cdot,\cdot),a,q}(\mathcal{R})$, which limit the number of retrieved results by their cardinality $k$ or a maximum cut-off distance $\epsilon$ respectively.

While postulating a new, relational operation $\tau^{kNN}_{\delta(\cdot,\cdot),a,q}(\mathcal{R})$ or $\tau^{\epsilon NN}_{\delta(\cdot,\cdot),a,q}(\mathcal{R})$ as proposed by \cite{Giangreco:2018thesis} has a certain elegance to it, it comes with limitations that become apparent upon disection of its structure. In its postulated form, $\tau$ addresses several functions at once:

\begin{enumerate}
    \item It specifies the distance function that should be evaluated and the provided arguments.
    \item It generates an implicit distance attribute on the underlying relation $\mathcal{R}$.
    \item It imposes an ascending ordering and limits the cardinality of $\mathcal{R}$ based on a predicate or a specified limit.
\end{enumerate}

While being very specific and thus straightforward to implement, the amalgamation of all this functionality into a single operation is very specifically tailored to the use-case of similarity search and only of limited value when considering more general proximity-based query operations. If one would, for example, want to obtain the $k$ farthest neighbours rather than the $k$ nearest neighbours, as necessary when doing MIPS or obtaining negative examples, we would have to either change the distance function or extend the definition of $\tau$. 

Another important issue with the definition of $\tau$ in its current form is that despite the two opreations $\tau^{kNN}_{\delta(\cdot,\cdot),a,q}(\mathcal{R})$ and $\tau^{\epsilon NN}_{\delta(\cdot,\cdot),a,q}(\mathcal{R})$ serving a very similar purpose, they behave very differently with respect to other operations. Generally, $\tau^{kNN}_{\delta(\cdot,\cdot),a,q}(\mathcal{R})$ does not commute with any selection $\sigma$ due to the inherent limiting of the cardinality to a constant value, hence:

\begin{equation}
    \label{equation:commutation_of_tau}
    \sigma(\tau^{kNN}_{\delta(\cdot,\cdot),a,q}(\mathcal{R})) \neq \tau^{kNN}_{\delta(\cdot,\cdot),a,q}(\sigma(\mathcal{R}))
\end{equation}

The left-hand side of \cref{equation:commutation_of_tau} filters the results of a kNN-search on $\mathcal{R}$, thus returning $n \leq k$ results, wherein $n = k$ only if $\sigma$ matches all tuples. The right-hand side of \cref{equation:commutation_of_tau} performs a kNN-search on a pre-filtered relation $\mathcal{R}$, also returning $n \leq k$ entries. However, $n$ will only be smaller than $k$ if $\sigma$ selects fewer than $k$ tuples.

The same isn't true for $\tau^{\epsilon NN}_{\delta(\cdot,\cdot),a,q}(\mathcal{R})$, due to the limitation of the cardinality being facilitated by an \emph{implicit} selection $\sigma_{\delta \leq \epsilon}$.

\begin{equation}
    \sigma(\tau^{\epsilon NN}_{\delta(\cdot,\cdot),a,q}(\mathcal{R})) = \tau^{\epsilon NN}_{\delta(\cdot,\cdot),a,q}(\sigma(\mathcal{R}))
\end{equation}

Hence, $\sigma$ and $\tau^{\epsilon NN}_{\delta(\cdot,\cdot),a,q}(\mathcal{R})$ commute and yield equivalent results as long as $\sigma$ does not rely on the distance attribute introduced by $\tau^{\epsilon NN}_{\delta(\cdot,\cdot),a,q}(\sigma(\mathcal{R}))$

\section{Queries: From Expression to Execution}

\subsection{Structured Query Language (SQL)}

\subsection{Query Planning}

\subsection{Query Execution}

\section{Storage, Indexes and Caching}

\section{Architectual Considerations}